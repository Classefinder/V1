<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Carte avec Leaflet, OSRM et GeoJSON</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-search@4.0.0/dist/leaflet-search.min.css" />  
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
  <script src="https://unpkg.com/leaflet-search@4.0.0/dist/leaflet-search.min.js"></script>  
</head>
<body>
  <div id="map" style="height: 100vh;"></div>

  <script>
    // --- 1. Initialisation de la carte et couche de fond ---
    var map = L.map('map').setView([45.9368, 6.1322], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // --- 2. Données GeoJSON pour l'étage 0 et l'étage 1 ---
    // Étage 0 : Salle A (Polygon) et Chemin associé (LineString)
    var salleEtage0 = {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": { "name": "Salle A" },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[[2.35, 48.85], [2.351, 48.85], [2.351, 48.851], [2.35, 48.851], [2.35, 48.85]]]
          }
        }
      ]
    };
    var cheminEtage0 = {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": { "name": "Salle A" },
          "geometry": {
            "type": "LineString",
            "coordinates": [[2.35, 48.85], [2.32, 48.852]]
          }
        }
      ]
    };

    // Étage 1 : Salle B (Polygon) et Chemin associé (LineString)
    var salleEtage1 = {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": { "name": "Salle B" },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[[2.353, 48.853], [2.354, 48.853], [2.354, 48.854], [2.353, 48.854], [2.353, 48.853]]]
          }
        }
      ]
    };
    var cheminEtage1 = {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": { "name": "Salle B" },
          "geometry": {
            "type": "LineString",
            "coordinates": [[2.353, 48.853], [2.355, 48.85]]
          }
        }
      ]
    };

    // --- 3. Création d'un calque par étage combinant salle et chemin ---
    var etage0 = L.geoJSON([salleEtage0, cheminEtage0], {
      style: function(feature) {
        if (feature.geometry.type === "Polygon") {
          return { color: 'red', weight: 2, fillOpacity: 0.4 };
        } else {  // LineString
          return { color: 'red', weight: 2, dashArray: '4' };
        }
      }
    }).addTo(map);

    var etage1 = L.geoJSON([salleEtage1, cheminEtage1], {
      style: function(feature) {
        if (feature.geometry.type === "Polygon") {
          return { color: 'blue', weight: 2, fillOpacity: 0.4 };
        } else {  // LineString
          return { color: 'blue', weight: 2, dashArray: '4' };
        }
      }
    }).addTo(map);

    // --- 4. Variables pour la gestion du point de départ de l'itinéraire ---
    var startPoint = null;  // Marqueur de départ (sera placé sur le chemin trouvé)
    var endPoint = null;    // Point d'arrivée (géré par vos autres interactions)

    // --- 5. Fonctions utilitaires de surlignage ---
    function highlightFeature(layer) {
      layer.setStyle({
        color: 'yellow',
        weight: 3,
        fillOpacity: 0.7
      });
      layer.bringToFront();
    }
    function resetHighlight() {
      etage0.setStyle({ color: 'red', weight: 2, fillOpacity: 0.4 });
      etage1.setStyle({ color: 'blue', weight: 2, fillOpacity: 0.4 });
    }

    // --- 6. Barre de recherche sur les calques combinés ---
    // On regroupe les deux calques dans un FeatureGroup
    var combinedGroup = L.featureGroup([etage0, etage1]);
    var searchControl = new L.Control.Search({
      layer: combinedGroup,
      propertyName: 'name',  // Recherche par propriété "name"
      marker: false,         // Pas de marqueur automatique
      moveToLocation: function(latlng, title, map) {
        map.setView(latlng, 17);
      }
    });

    searchControl.on('search:locationfound', function(e) {
      // Réinitialiser le style de tous les éléments (sans toucher aux calques)
      resetHighlight();

      // Déterminer dans quel calque se trouve la feature trouvée
      var currentEtage = null;
      if (etage0.getLayers().indexOf(e.layer) !== -1) {
        currentEtage = etage0;
      } else if (etage1.getLayers().indexOf(e.layer) !== -1) {
        currentEtage = etage1;
      }

      // On souhaite surligner la salle (Polygon) et non le chemin.
      // Si la feature trouvée est déjà un Polygon, c'est celle-ci ; sinon, on cherche le Polygon ayant le même nom dans le même calque.
      var salleLayer = null;
      if (e.layer.feature.geometry.type === "Polygon") {
        salleLayer = e.layer;
      } else if (currentEtage) {
        currentEtage.eachLayer(function(layer) {
          if (layer.feature &&
              layer.feature.properties.name === e.layer.feature.properties.name &&
              layer.feature.geometry.type === "Polygon") {
            salleLayer = layer;
          }
        });
      }
      if (salleLayer) {
        highlightFeature(salleLayer);
      }

      // Dans le même calque, rechercher la feature de type LineString (le chemin) avec le même nom.
      if (currentEtage) {
        var matchingChemin = null;
        currentEtage.eachLayer(function(layer) {
          if (layer.feature &&
              layer.feature.properties.name === e.layer.feature.properties.name &&
              layer.feature.geometry.type === "LineString") {
            matchingChemin = layer;
          }
        });
        if (matchingChemin) {
          var center = matchingChemin.getBounds().getCenter();
          // Si un marqueur de départ existe déjà, on le supprime
          if (startPoint) { 
            map.removeLayer(startPoint);
          }
          // On place le marqueur de départ de l’itinéraire sur le centre du chemin trouvé
          startPoint = L.marker(center).addTo(map)
            .bindPopup("Point de départ sur le chemin de " + e.layer.feature.properties.name)
            .openPopup();
        }
      }
    });

    searchControl.on('search:collapsed', resetHighlight);
    map.addControl(searchControl);

    // --- 7. Gestion du clic sur la carte pour définir départ et arrivée ---
    // (Votre code OSRM existant – ici, on ne vide pas les calques salles/chemins)
    map.on('click', function(event) {
      if (startPoint) {
        map.removeLayer(startPoint);
      }
      if (!startPoint) {
        startPoint = L.marker(event.latlng).addTo(map).bindPopup("Point de départ").openPopup();
      } else if (!endPoint) {
        endPoint = [event.latlng.lat, event.latlng.lng];
        L.marker(endPoint).addTo(map).bindPopup("Point d'arrivée").openPopup();
        getRouteAndPoints([startPoint.getLatLng().lat, startPoint.getLatLng().lng], endPoint);
      } else {
        // Réinitialisation sans vider les calques combinés
        startPoint = null;
        endPoint = null;
        map.eachLayer(function(layer) {
          if (layer instanceof L.Marker || layer instanceof L.Polyline) {
            // On ne retire pas les calques combinés (et donc pas les salles/chemins)
            if (layer !== etage0 && layer !== etage1) {
              map.removeLayer(layer);
            }
          }
        });
      }
    });

    // --- 8. Fonction de récupération de l'itinéraire (OSRM) ---
    // Notez : ici, nous n'effaçons pas les calques salles/chemins.
    function getRouteAndPoints(start, end) {
      var osrmUrl = `http://89.168.57.91:5000/route/v1/driving/${start[1]},${start[0]};${end[1]},${end[0]}?steps=true&geometries=geojson&overview=full`;
      fetch(osrmUrl)
        .then(response => response.json())
        .then(data => {
          if (data.routes && data.routes.length > 0) {
            var route = data.routes[0];
            // Pour chaque segment de l'itinéraire, on l'ajoute directement sur la carte
            route.legs[0].steps.forEach(function(step) {
              var segment = {
                type: "Feature",
                geometry: step.geometry,
                properties: { name: step.name || "" }
              };
              // On ajoute le segment sur la carte (sans vider le calque existant)
              L.geoJSON(segment, {
                style: { color: 'purple', weight: 4 }
              }).addTo(map);
            });
            var bounds = L.geoJSON(route.geometry).getBounds();
            map.fitBounds(bounds);
          }
        })
        .catch(error => {
          console.error('Erreur lors de la récupération de l’itinéraire:', error);
        });
    }
  </script>
</body>
</html>
